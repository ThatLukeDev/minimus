\documentclass{article}

\usepackage{caption}
\usepackage[newfloat]{minted}
\captionsetup[listing]{position=top}

\title{OS Development}
\author{Luke}

\begin{document}

\maketitle

\begin{abstract}

This document serves as a reference for the Minimus operating system.

\end{abstract}

\newpage

\tableofcontents

\newpage

\section{Bootloader}

\subsection{Headers}

The disk is ordered into sectors, of size 200$_{16}$, starting from sector 1\cite{sector size}.
When the BIOS loads the OS, it copies the first sector,
which would be the first 512 bytes, from the disk into memory,
starting at 7C00$_{16}$\cite{7c00}.

Memory is also ordered into segments, of size 10$_{16}$\cite{memory segments}. This means that memory
addresses can overlap, for example:
The address 0000:7C00$_{16}$ is the same as 0700:0C00$_{16}$.

You must ensure that the bytes at 1FE$_{16}$ and 1FF$_{16}$
contain values 55$_{16}$ and AA$_{16}$ respectively\cite{55aa}.
This is called the magic number, and is used to differentiate
bootable disks from non-bootable disks.

When the BIOS hands control to the OS, the CPU will be in 16 bit (real) mode\cite{16bitstart},
which means it is using 16 bits per instruction. This is because the CPU is in
16 bit mode by default. You must ensure that your program code for the bootloader
begins in 16 bit (assuming real) mode.

\begin{verbatim}
bootloader/main.asm
\end{verbatim}
\begin{minted}[linenos,frame=single,breaklines]{nasm}
[org 0x7c00]		; memory load location
[bits 16]		; real mode
\end{minted}

\subsection{Disk read}

Reading from the disk is done with Bios Interrupt 13$_{16}$ ah=02\cite{int 13h}.
\\\\
The interrupt specification is layed out below\ref{int 13 ah 02}:
\\

\begin{tabular}{|r|l|}
	\hline
	\textbf{Register} & \textbf{Value} \\
	\hline
	AH & 02 \\
	\hline
	AL & Number of sectors to read \\
	\hline
	CH & Cylinder \\
	\hline
	DH & Head \\
	\hline
	CL & Sector \\
	\hline
	DL & Drive \\
	\hline
	ES:BX & Output offset \\
	\hline
\end{tabular}
\\\\\\
Since the DL register is initialised with the boot drive before control
is handed to our program\cite{boot drive init}, as long as it is not
overwritten before calling int 13$_{16}$, you do not have to alter it.

Since the ES register cannot be written to directly, due to no CPU instruction
being availible to transfer a value to ES\cite{segment cpu write instruction},
which results in an intemediary value needing to be used.

I decided to use BX, due to it being overwritten used in the instruction after,
but any unused register will do. Then, I assigned BX with 7e00$_{16}$, which is
$200_{16}$ bytes more than the start of the program\cite{7c00}, which is the
precise number of bytes loaded by the BIOS\cite{sector size}.

The number of load segments (register AX)\cite{int 13h} have a limit of around 100
on some systems, and around 70 on QEMU. 64 is a safe number of sectors to load,
and allows for 32KB of kernel instructions (which is far more than enough).

Sometimes there will be an error, stored in the carry bit\cite{int 13h}, if this
happens, retry the load from disk. An error may also be indicated by the AL register
having an incorrect number of sectors read.

\begin{verbatim}
bootloader/main.asm
\end{verbatim}
\begin{minted}[linenos,frame=single,breaklines]{nasm}
KERNEL_SEGS equ 64	; KERNEL_SEGS * 512

; read kernel (https://en.wikipedia.org/wiki/INT_13H)
mov bx, 0
mov es, bx
mov bx, 0x7e00		; offset
mov ah, 0x02		; set read mode
mov cl, 2		; start from sec 2
mov al, KERNEL_SEGS	; sectors to read
mov ch, 0		; cylinder
mov dh, 0		; head
int 0x13		; call
jc $$			; carry bit stores error, loop
cmp al, KERNEL_SEGS	; al is sectors read
jne $$			; if all sectors arent read, loop
\end{minted}

\subsection{Usable memory}

The amount of usable memory varies between systems,
and some memory is reserved for hardware, VGA and VBE,
console video memory, etc.

Detecting availible memory blocks is done with interrupt
15$_{16}$\cite{int 15h}\ref{int 15 0xe820}. Although you can probably get
away with ignoring this, and just hoping memory above,
lets say 1mb, is completely fine, I went through the extra
effort to correctly get usable memory.

This area repeatedly calls int 15$_{16}$, and saves the result,
if it is larger than the currently tested memory, in a memory location
ironically not tested to see if it is reserved.

The copying and checking is done in two parts due to the fact
that the numbers are larger than the 16 bit memory availible in real mode.

\begin{verbatim}
bootloader/main.asm
\end{verbatim}
\begin{minted}[linenos,frame=single,breaklines]{nasm}
; get largest availible memory block
pusha			; push all
mov cx, 0x0		; clear cx for addition later
xor eax, eax
mov es, eax
mov ebx, 0x0		; clear
mov edx, 0x534d4150	; magic value
memreadloop:
	mov eax, 0xe820	    ; magic value
	mov ecx, 0x18	    ; magic value
	mov di, 0x7bd0	    ; memory location for buffer
	int 0x15	    ; call function
	add di, cx    ; increment di by entry size
	              ; (cx is 16 bit cl)
memreadloopvalid:
	mov eax, [0x7be0]    ; load type
	cmp eax, 1	    ; check if 1 (availible memory)
	jne memreadloopend    ; go to next otherwise
memreadloopcheck:
	mov eax, [0x7bda]	; load size of current
	mov ecx, [0x7bfa]	; load size of biggest
	cmp eax, ecx		; check if bigger
	jle memreadloopend	; go to next otherwise
memreadlooprecord:
	mov eax, [0x7bd0]	; load address of current
	mov [0x7bf0], eax	; record biggest address
	mov eax, [0x7bd4]	; load address of current
	mov [0x7bf4], eax	; record biggest address
	mov eax, [0x7bd8]	; load size of current
	mov [0x7bf8], eax	; record biggest size
	mov eax, [0x7bdc]	; load size of current
	mov [0x7bfc], eax	; record biggest size
memreadloopend:
	cmp ebx, 0		; check if next
	jnz memreadloop		; repeat
\end{minted}

\subsection{Display}

\subsubsection{VGA}

Enabling VGA\cite{vga} here allows me to get the font later,
and also serves as compatibility for if VESA is not supported.

The options for AL are defined\ref{vga}.

\begin{verbatim}
bootloader/main.asm
\end{verbatim}
\begin{minted}[linenos,frame=single,breaklines]{nasm}
; vga mode
mov ah, 0x0		; graphics mode
mov al, 0x13		; 256 colour 200x320
int 0x10		; set vga mode
\end{minted}

\subsubsection{Font}

The code below gets the font from the VGA card. This
is so I did not have to store my own.

The code is taken mostly from this OsDev page\cite{get vga font},
due to the fact that I figured it was mostly copy paste anyway.

\begin{verbatim}
bootloader/main.asm
\end{verbatim}
\begin{minted}[linenos,frame=single,breaklines]{nasm}
; get vga font
mov eax, 0x100
mov es, eax
mov ax, 0x0
mov di, ax
push ds
push es
mov ax, 0x1130		; magic numbers
mov bh, 0x6
int 0x10		; get vga font
;mov ds, es
push es
pop ds
pop es
mov si, bp
mov cx, 0x400
rep movsd
pop ds
\end{minted}

\subsubsection{VBE}

The VESA bios extensions allows for greater colour depth (RGB) and higher
resolutions than VGA. Getting the VBE table is done with interrupt 10$_{16}$\cite{vbe}.

Once sifted to find the right function, it can again be enabled with
interrupt 10$_{16}$, the magic numbers for each function are in the
VBE spec\cite{vbe}.

The resulting values (whether 24 bit or 32 bit colour is used, the location of
the framebuffer, whether VBE is even supported in the first place, etc), are placed
into another (not checked) area of memory, which will be used by the kernel later.

I start by checking for VBE2 support, and if it doesn't exist I jump to the end of
the VBE section.
Then I go through each function, checking if it has RGB colourspace, and is the
correct resolution.
I then update the bytes at some position (again not fully checked) so my kernel has access
to whether VBE was enabled or not, and also to provide the kernel with
the position of the linear framebuffer.

This is due to the fact that in VBE2, it is not required that all the VBE1 functions\ref{vbe}
are supported (even though they most likely are).

Enabling a VBE mode is as simple as VBE once the functions have been sorted, and
is the same BIOS interrupt\ref{vbe enable}.

\begin{verbatim}
bootloader/main.asm
\end{verbatim}
\begin{minted}[linenos,frame=single,breaklines]{nasm}
; get vesa support
mov [0x2000], DWORD "VBE2"
mov ax, 0x4f00		; magic number
mov di, 0
mov es, di
mov di, 0x2000		; offset to table
int 0x10		; get vbe table
cmp ax, 0x004f		; check if support
jne skip_vbe		; use vga instead if not

mov di, 0		; offset to tmp
mov es, di
mov di, 0x2200		; segment to tmp
mov si, [0x2000 + 16]	; segment of list
mov ds, si
mov si, [0x2000 + 14]	; offset of list

vbe_loop:
; get next supported vesa function
movsw
sub di, 2		; (2 is added to both)
mov cx, [0x2200]	; vesa mode
cmp cx, 0xffff		; check if end
je skip_vbe		; loop

; get details
mov ax, 0x4f01		; magic number
int 0x10		; get vbe

mov ax, [0x2200]	; check attr
and ax, 0b10000000	; check bit 7 (linear framebuffer)
cmp ax, 0
jz vbe_loop		; if not linear, loop

mov al, [0x2200 + 25]	; check colourspace
mov [0x2201], BYTE 0x00	; vbe 32 bit flag
cmp al, 24
je vbe_check_dims	; if not rgb, loop
mov [0x2201], BYTE 0xff	; vbe 32 bit flag
cmp al, 32
je vbe_check_dims	; if not rgb, loop
jmp vbe_loop		; actual loop

vbe_check_dims:
mov ax, [0x2200 + 18]	; check width
cmp ax, 640
jne vbe_loop		; if not desired, loop

mov ax, [0x2200 + 20]	; check height
cmp ax, 480
jne vbe_loop		; if not desired, loop

jmp enable_vbe		; turn on this vbe

skip_vbe:
mov [0x2200], BYTE 0x00	; vbe corect flag
jmp complete_vbe	; skip

enable_vbe:
mov ax, [0x2200 + 40]	; framebuffer
mov [0x2200 + 2], ax	; framebuffer
mov ax, [0x2200 + 42]	; framebuffer
mov [0x2200 + 4], ax	; framebuffer
mov ax, 0x4f02		; magic number
mov bx, cx		; move mode number
or bx, 0x4000		; set linear framebuffer
int 0x10		; set vbe mode
cmp ax, 0x004f		; test for error
jne skip_vbe		; skip if error (will use vga instead)
mov [0x2200], BYTE 0xff	; vbe correct flag

complete_vbe:
popa			; pop all
\end{minted}

\subsection{Enabling 32-bit processing}

\subsubsection{Segment descriptor}

The Global Descriptor Table is necessary for enabling protected mode\cite{gdt},
and is defined below in a basic form in order to switch to protected mode.

For my kernel, none of the features of the GDT, like paging\cite{gdt page},
are not needed, so the GDT is very basic\ref{gdt}.

\begin{verbatim}
bootloader/main.asm
\end{verbatim}
\begin{minted}[linenos,frame=single,breaklines]{nasm}
jmp gdt_after

; segment descriptor (reverse order)
gdt_start:
	dq 0		; null byte start
gdt_code:
	dw 0xffff	; segment limit
	db 0,0,0	; segment base
	db 0b10011010	; flags (see wiki)
	db 0b11001111	; 4b flags (see wiki) + seg limit
	db 0		; segment base
gdt_data:
	dw 0xffff	; segment limit
	db 0,0,0	; segment base
	db 0b10010010	; flags (see wiki)
	db 0b11001111	; 4b flags (see wiki) + seg limit
	db 0		; segment base
gdt_end:
	dw gdt_end - gdt_start - 1	; limit
	dd gdt_start			; addr 24 bit
gdt_after:
\end{minted}

\subsubsection{Prerequisites}

To enable protected mode, you must first disable interrupts,
and load the global descriptor table\cite{intel protected mode enable},
which can be done in NASM with commands \verb|cli| and \verb|lgdt [GDT ADDRESS]| respectively.

\begin{verbatim}
bootloader/main.asm
\end{verbatim}
\begin{minted}[linenos,frame=single,breaklines]{nasm}
cli			; disable interrupts
lgdt [gdt_end]		; gdt_end is descritor table descriptor
\end{minted}

\subsubsection{Protected mode}

Upon the completion of all the above, you can then set bit 0 (starting from 0)
to 1 in the control register CR0\cite{intel protected mode enable}, which must be done
in seperate commands, as the special register CR0 is not directly assignable\cite{segment cpu write instruction}.

You must then immediately\cite{intel protected mode enable} perform a long jump
to your next desired instruction.

You then have to tell the assembler that you are now using 32 bits, which can
be done with the \verb|[bits 32]| command in NASM.

\begin{verbatim}
bootloader/main.asm
\end{verbatim}
\begin{minted}[linenos,frame=single,breaklines]{nasm}
mov eax, cr0
or eax, 1		; set 1 bit in control register for protected mode
mov cr0, eax
jmp (gdt_code - gdt_start):bits32code	; stall cpu and flush all cache (as moving to different segment) to finalize protected mode

; finally 32 bits
[bits 32]
bits32code:
\end{minted}

\subsection{Enabling the A20 line}

Enabling the A20 line (the proper way) is by the keyboard\cite{a20}. This is
incredibly tedious and repetitive, which is why I have taken
this code from the OsDev page.

Two small assembly functions: a20wait; a20waitr, have been created
to avoid some of the repetition. a20wait will repeatedly poll
port 64$_{16}$ until bit 1 is set (which is why \verb|TEST| is used).
a20waitr will do the same until bit 0 is set.

This is due to the fact that it is required to wait for bit 1 in port
64$_{16}$ before writing and bit 0 in port 64$_{16}$ before reading.

A brief outline of the functions of the A20 line are provided
within this document\ref{a20}.

\begin{verbatim}
bootloader/main.asm
\end{verbatim}
\begin{minted}[linenos,frame=single,breaklines]{nasm}
xor al, al
call a20wait		; wait for write
mov al, 0xad
out 0x64, al		; send 0xad
call a20wait		; wait for write
mov al, 0xd0
out 0x64, al		; send 0xd0
call a20waitr		; wait for read
in al, 0x60		; get ack
push eax
call a20wait		; wait for write
mov al, 0xd1
out 0x64, al		; send 0xd1
call a20wait		; wait for write
pop eax			; eax gets overwritten
or al, 0b0010		; a20 bit
out 0x60, al		; set a20 bit on
call a20wait		; wait for write
mov al, 0xae
out 0x64, al		; send 0xae
call a20wait		; wait for generic
jmp skipa20		; go to end
a20wait:
	in al, 0x64
	test al,2
	jnz a20wait
	ret
a20waitr:
	in al, 0x64
	test al,1
	jz a20waitr
	ret

skipa20:
\end{minted}

\subsection{Loading the Kernel}

Before loading the kernel, I initialise all the registers high parts
with the segment and move the stack pointers to 7000$_{16}$.

The bootloader begins at 7c00$_{16}$\cite{7c00}, and because the
stack grows downwards, 7000$_{16}$ is a perfect location for a
stack. You can place yours where you like.

\begin{verbatim}
bootloader/main.asm
\end{verbatim}
\begin{minted}[linenos,frame=single,breaklines]{nasm}
jmp (gdt_code - gdt_start):start_kernel

start_kernel:
	; segment registers init
	mov ax, gdt_data - gdt_start
	mov ds, ax
	mov es, ax
	mov fs, ax
	mov gs, ax
	mov ss, ax

	; stack pointers
	mov esp, 0x7000		; top of stack
	mov ebp, esp		; bottom of stack

	call kernel		; start kernel and move back to segment

; kernel
kernel:
	jmp kernel_loadseg	; hand control to kernel
	jmp $$			; return -> error, loop

			...

; kernel load
kernel_loadseg:
call kernel_cseg
jmp $				; if fail restart
kernel_cseg:			; compiled c appeneded here
\end{minted}

\subsection{The boot signature}

You must ensure that the bytes at 1FE$_{16}$ and 1FF$_{16}$
contain values 55$_{16}$ and AA$_{16}$ respectively\cite{55aa}.
This is called the boot signature, or magic number, and is used to differentiate
bootable disks from non-bootable disks, and also tells the BIOS how to load your OS.

\begin{verbatim}
bootloader/main.asm
\end{verbatim}
\begin{minted}[linenos,frame=single,breaklines]{nasm}
; padding
times 510 - ($-$$) db 0

; boot signature
db 0x55,0xaa
\end{minted}

\newpage

\section{Kernel}

The kernel is mostly written in C, with occasional exceptions like the IDT,
which is written in NASM assembly.

\subsection{Port Utils}

Many kernel functions require reading and writing data to the
serial bus, so I have made functions for code readibility.

GCC inline assembly has three major parts:
the instruction - which is written in GNU assembly;
the input value - (e.g. "=a"(val) to save to val);
the output value - (e.g. "a"(val) to load from val),
all seperated by colons.

\begin{verbatim}
kernel/libs/ioutils.c
\end{verbatim}
\begin{minted}[linenos,frame=single,breaklines]{c}
void outb(unsigned short port, unsigned char val) {
	__asm__ volatile ("outb %b0, %w1" : : "a"(val), "Nd"(port) : "memory");
}

unsigned char inb(unsigned short port) {
	unsigned char _ret = 0;

	__asm__ volatile ("inb %w1, %b0" : "=a"(_ret) : "Nd"(port) : "memory");

	return _ret;
}

void outw(unsigned short port, unsigned short val) {
	__asm__ volatile ("outw %w0, %w1" : : "a"(val), "Nd"(port) : "memory");
}

unsigned short inw(unsigned short port) {
	unsigned short _ret = 0;

	__asm__ volatile ("inw %w1, %w0" : "=a"(_ret) : "Nd"(port) : "memory");

	return _ret;
}

void iowait() {
	outb(0x80, 0);
}
\end{minted}

\subsection{VGA/VBE}

VGA is outdated, so is only used as a backup in this OS, in case VBE2 fails
to load for whatever reason, or is not supported.

\subsubsection{Initialisation}

VGA memory is set at A0000$_{16}$, whereas VBE uses a variable position
linear framebuffer. In the bootloader, when VBE2 was enabled, the linear
framebuffer was stored at 2200$_{16}$, so it is loaded from there.

Additionally, whether VBE was sucessfully enabled is loaded, as well as
how many bits per pixel are used (on some systems it is 4).

The width and height is pre-defined for this kernel, so is not needed
to be gathered from anywhere.

For compatibility, the VGA colourspace is loaded with a compressed version
of RGB (for 8 bits: RRRGGGBB).

\begin{verbatim}
kernel/libs/vga.c
\end{verbatim}
\begin{minted}[linenos,frame=single,breaklines]{c}
#include "ioutils.h"

extern void getvgafont();

#define VGA_MEM (unsigned char*)0xa0000
#define VGA_WIDTH 320
#define VGA_HEIGHT 200

#define VBE_WIDTH 640
#define VBE_HEIGHT 480
unsigned char vbeEnabled = 0;
unsigned char vbeAlpha = 3;
unsigned char* vbeFramebuffer = (unsigned char*)0x0;

unsigned char* font = (unsigned char*)0x1000; // defined in bootloader/main.asm

void initvga() {
	vbeEnabled = *(unsigned char*)0x2200;
	if (*(unsigned char*)0x2201)
		vbeAlpha = 4;
	else
		vbeAlpha = 3;

	if (vbeEnabled) {
		vbeFramebuffer = (unsigned char*)(*(unsigned int*)0x2202);
	}
	else {
		for (int i = 0; i < 256; i++) {
			unsigned char r = (i & 0b11100000) >> 2; // highest value is 0b00111111 as 18 bit colour space
			unsigned char g = (i & 0b00011100) << 1;
			unsigned char b = (i & 0b00000011) << 4; // used less bits for blue as eyes are less sensitive

			outb(0x3c8, i); // set DAC address
			outb(0x3c9, r); // set DAC R for i
			outb(0x3c9, g); // set DAC G for i
			outb(0x3c9, b); // set DAC B for i
		}
	}
}
\end{minted}

\subsubsection{Setting pixel values}

Setting pixel values in VGA and VBE are similar, with the exception
that in VBE, you may need to have an extra alpha bit that is left alone.
I handled this case as below.

In VGA, I have compressed the colourspace down to the values allowed,
and while this looks low quality, it serves as a great fallback
for old systems with very little overhead.

\begin{verbatim}
kernel/libs/vga.c
\end{verbatim}
\begin{minted}[linenos,frame=single,breaklines]{c}
void drawpixel(int _x, int _y, unsigned char r, unsigned char g, unsigned char b) {
	if (vbeEnabled) {
		*(vbeFramebuffer + _x * vbeAlpha + vbeAlpha - 3 + _y * VBE_WIDTH * vbeAlpha) = b;
		*(vbeFramebuffer + _x * vbeAlpha + vbeAlpha - 2 + _y * VBE_WIDTH * vbeAlpha) = g;
		*(vbeFramebuffer + _x * vbeAlpha + vbeAlpha - 1 + _y * VBE_WIDTH * vbeAlpha) = r;
	}
	else {
		_x /= 2;
		_y /= 3;
		*(VGA_MEM + _x + _y * VGA_WIDTH) = (r & 0b11100000) | ((g >> 3) & 0b00011100) | ((b >> 6) & 0b00000011);
	}
}
\end{minted}

\subsubsection{Drawing characters}

For drawing characters, you need a font. Although the kernel
currently has a filesystem, at the time I implemented the display,
it did not.

I decided to append the bootloader's VGA code with code to
load the VGA BIOS currently used font (as it was easier
to do this with BIOS interrupts).

This code is covered in the Bootloader chapter, so I will not
be covering this. The pointer has been assigned to the \verb|font|
variable.

\begin{verbatim}
kernel/libs/vga.c
\end{verbatim}
\begin{minted}[linenos,frame=single,breaklines]{c}
void drawchar(int _x, int _y, unsigned char _char) {
	unsigned char* fontchar = font + ((int)_char * 16);

	for (int y = 0; y < 16; y++) {
		for (int x = 0; x < 8; x++) {
			if (fontchar[y] & (0b10000000 >> x)) {
				drawpixel(_x * 8 + x, _y * 16 + y, 0xff, 0xff, 0xff);
			}
			else {
				drawpixel(_x * 8 + x, _y * 16 + y, 0x00, 0x00, 0x00);
			}
		}
	}
}
\end{minted}

\newpage

\section{Appendix}
\appendix

\subsection{INT 13$_{16}$ AH 02$_{16}$}
\label{int 13 ah 02}

\begin{tabular}{|r|l|}
	\hline
	\textbf{Register} & \textbf{Value} \\
	\hline
	AL & Number of sectors to read \\
	\hline
	CH & Cylinder \\
	\hline
	DH & Head \\
	\hline
	CL & Sector \\
	\hline
	DL & Drive \\
	\hline
	ES:BX & Output offset \\
	\hline
\end{tabular}

\subsection{Segment Descriptor}
\label{gdt}

\begin{tabular}{|r|c|l|}
	\hline
	\textbf{Bits} & \textbf{Segment} & \textbf{Value} \\
	\hline
	0-15 & \emph{(1)} & Segment limit \\
	\hline
	16-39 & \emph{(1)} & Segment base \\
	\hline
	40-43 & \emph{(flag)} & Type \\
	\hline
	44 & \emph{(flag)} & S \\
	\hline
	45-46 & \emph{(flag)} & DPL \\
	\hline
	47 & \emph{(flag)} & P \\
	\hline
	48-51 & \emph{(2)} & Segment limit \\
	\hline
	52 & \emph{(flag)} & A \\
	\hline
	53 & \emph{(null)} & 0 \\
	\hline
	54 & \emph{(flag)} & DB \\
	\hline
	55 & \emph{(flag)} & G \\
	\hline
	56-63 & \emph{(2)} & Segment base \\
	\hline
\end{tabular}

\subsection{INT 15$_{16}$ EAX E820$_{16}$}
\label{int 15 0xe820}

\begin{tabular}{|r|l|}
	\hline
	\textbf{Register} & \textbf{Value} \\
	\hline
	EAX & E820$_{16}$ \\
	\hline
	EBX & 0 \\
	\hline
	ECX & 24 \\
	\hline
	EDX & 534D4150$_{16}$ \\
	\hline
	ES:DI & Output buffer \\
	\hline
\end{tabular}

\subsection{VGA Options}
\label{vga}

\begin{tabular}{|r|c|c|l|}
	\hline
	\textbf{Value} & \textbf{Type} & \textbf{Resolution} & \textbf{Colourspace} \\
	\hline
	00$_{16}$ & Text & 40x25 & 1 \\
	\hline
	01$_{16}$ & Text & 40x25 & 16 \\
	\hline
	02$_{16}$ & Text & 80x25 & 1 \\
	\hline
	03$_{16}$ & Text & 80x25 & 16 \\
	\hline
	04$_{16}$ & CGA & 320x200 & 4 \\
	\hline
	05$_{16}$ & CGA & 320x200 & 1 \\
	\hline
	06$_{16}$ & CGA & 640x200 & 2 \\
	\hline
	07$_{16}$ & MDA & 80x25 & 1 \\
	\hline
	0D$_{16}$ & EGA & 320x200 & 16 \\
	\hline
	0E$_{16}$ & EGA & 640x200 & 16 \\
	\hline
	0F$_{16}$ & EGA & 640x350 & 1 \\
	\hline
	10$_{16}$ & EGA & 640x350 & 16 \\
	\hline
	11$_{16}$ & VGA & 640x480 & 1 \\
	\hline
	12$_{16}$ & VGA & 640x480 & 16 \\
	\hline
	13$_{16}$ & VGA & 320x200 & 256 \\
	\hline
\end{tabular}

\subsection{VBE1 Functions}
\label{vbe}

\begin{tabular}{|r|c|c|l|}
	\hline
	\textbf{Value} & \textbf{Type} & \textbf{Resolution} & \textbf{Colourspace} \\
	\hline
	100$_{16}$ & Graphics & 640x400 & 256 \\
	\hline
	101$_{16}$ & Graphics & 640x480 & 256 \\
	\hline
	103$_{16}$ & Graphics & 800x600 & 256 \\
	\hline
	104$_{16}$ & Graphics & 1024x768 & 16 \\
	\hline
	105$_{16}$ & Graphics & 1024x768 & 256 \\
	\hline
	106$_{16}$ & Graphics & 1280x1024 & 16 \\
	\hline
	107$_{16}$ & Graphics & 1280x1024 & 256 \\
	\hline
	10D$_{16}$ & Graphics & 320x200 & 32K (1:5:5:5) \\
	\hline
	10E$_{16}$ & Graphics & 320x200 & 64K (5:6:5) \\
	\hline
	10F$_{16}$ & Graphics & 320x200 & 16.8M (8:8:8) \\
	\hline
	110$_{16}$ & Graphics & 640x480 & 32K (1:5:5:5) \\
	\hline
	111$_{16}$ & Graphics & 640x480 & 64K (5:6:5) \\
	\hline
	112$_{16}$ & Graphics & 640x480 & 16.8M (8:8:8) \\
	\hline
	113$_{16}$ & Graphics & 800x600 & 32K (1:5:5:5) \\
	\hline
	114$_{16}$ & Graphics & 800x600 & 64K (5:6:5) \\
	\hline
	115$_{16}$ & Graphics & 800x600 & 16.8M (8:8:8) \\
	\hline
	116$_{16}$ & Graphics & 1024x768 & 32K (1:5:5:5) \\
	\hline
	117$_{16}$ & Graphics & 1024x768 & 64K (5:6:5) \\
	\hline
	118$_{16}$ & Graphics & 1024x768 & 16.8M (8:8:8) \\
	\hline
	119$_{16}$ & Graphics & 1280x1024 & 32K (1:5:5:5) \\
	\hline
	11A$_{16}$ & Graphics & 1280x1024 & 64K (5:6:5) \\
	\hline
	11B$_{16}$ & Graphics & 1280x1024 & 16.8M (8:8:8) \\
	\hline
\end{tabular}

\subsection{INT 10$_{16}$ AX 4F02$_{16}$}
\label{vbe enable}

\begin{tabular}{|r|l|}
	\hline
	\textbf{Register} & \textbf{Value} \\
	\hline
	AX & 4F02$_{16}$ \\
	\hline
	BX & Mode \\
	\hline
	BX & 4XXX$_{16}$ for linear framebuffer \\
	\hline
\end{tabular}

\subsection{Enabling A20 Line through the Keyboard Controller}
\label{a20}

\begin{tabular}{|r|l|}
	\hline
	\textbf{Port} & \textbf{Value} \\
	\hline
	64$_{16}$ & AD$_{16}$ \\
	\hline
	64$_{16}$ & D0$_{16}$ \\
	\hline
	60$_{16}$ & \emph{read} \\
	\hline
	64$_{16}$ & D1$_{16}$ \\
	\hline
	60$_{16}$ & \emph{(read) $_{OR}$ 2} \\
	\hline
	64$_{16}$ & AE$_{16}$ \\
	\hline
\end{tabular}

\newpage

\begin{thebibliography}{99}
	\bibitem{7c00}
		Compaq Computer Corporation, Phoenix Technologies Ltd, Intel Corporation (1996)
		\emph{BIOS Boot Specification}
		pg 29 ch 6.5.1
	\bibitem{int 13h}
		Ralf Brown (2000)
		\emph{Ralf Browns Interrupt List}
		interrup b int 13
	\bibitem{sector size}
		IDEMA (2013)
		\emph{The Advent of Advanced Format}
		pg 1
	\bibitem{memory segments}
		Intel Corporation (2016)
		\emph{Intel 64 and IA-32 Architectures Software Developer’s Manual Volume 1: Basic Architecture}
		pg 1.6 ch 1.3.4
	\bibitem{55aa}
		Compaq Computer Corporation, Phoenix Technologies Ltd, Intel Corporation (1996)
		\emph{BIOS Boot Specification}
		pg 12 ch 3.3
	\bibitem{16bitstart}
		Intel Corporation (2016)
		\emph{Intel 64 and IA-32 Architectures Software Developer’s Manual Volume 3A: System Programming Guide, Part 1}
		pg 11.13 ch 1.9.1
	\bibitem{boot drive init}
		Compaq Computer Corporation, Phoenix Technologies Ltd, Intel Corporation (1996)
		\emph{BIOS Boot Specification}
		pg 43 ch D.1
	\bibitem{segment cpu write instruction}
		Intel Corporation (2022)
		\emph{Intel 64 and IA-32 Architectures Software Developer’s Manual Volume 2 (2A, 2B, 2C, 2D): Instruction Set Reference, A-Z}
		pg 4.35 ch 3.3
	\bibitem{gdt}
		Wikipedia (2024)
		\emph{Global Descriptor Table}
		ch Description
	\bibitem{a20}
		Robert Collins (2001)
		\emph{A20/Reset Anomalies}
		ch A20/Reset Anomalies
	\bibitem{gdt page}
		Wikipedia (2024)
		\emph{Global Descriptor Table}
		ch Modern Usage
	\bibitem{int 15h}
		OsDev (2024)
		\emph{Detecting Memory (x86)}
		ch 2.1
	\bibitem{get vga font}
		OsDev (2024)
		\emph{VGA Fonts}
		ch 2.4
	\bibitem{vga}
		Wikipedia (2024)
		\emph{Mode 13h}
		ch 2.4
	\bibitem{vbe}
		Video Electronics Standards Association (1998)
		\emph{VESA BIOS EXTENSION (VBE) Core Functions Standard}
		pg 17
	\bibitem{intel protected mode enable}
		Intel Corporation (2016)
		\emph{Intel 64 and IA-32 Architectures Software Developer’s Manual Volume 3A: System Programming Guide, Part 1}
		pg 9.17 ch 9.9.2
\end{thebibliography}

\end{document}
