\documentclass{article}

\usepackage{caption}
\usepackage[newfloat]{minted}
\captionsetup[listing]{position=top}

\title{OS Development}
\author{Luke}

\begin{document}

\maketitle

\begin{abstract}

This document serves as a reference for the Minimus operating system.

\end{abstract}

\newpage

\tableofcontents

\newpage

\section{Bootloader}

\subsection{Headers}

The disk is ordered into sectors, of size 200$_{16}$, starting from sector 1\cite{sector size}.
When the BIOS loads the OS, it copies the first sector,
which would be the first 512 bytes, from the disk into memory,
starting at 7C00$_{16}$\cite{7c00}.

Memory is also ordered into segments, of size 10$_{16}$\cite{memory segments}. This means that memory
addresses can overlap, for example:
The address 0000:7C00$_{16}$ is the same as 0700:0C00$_{16}$.

You must ensure that the bytes at 1FE$_{16}$ and 1FF$_{16}$
contain values 55$_{16}$ and AA$_{16}$ respectively\cite{55aa}.
This is called the magic number, and is used to differentiate
bootable disks from non-bootable disks.

When the BIOS hands control to the OS, the CPU will be in 16 bit (real) mode\cite{16bitstart},
which means it is using 16 bits per instruction. This is because the CPU is in
16 bit mode by default. You must ensure that your program code for the bootloader
begins in 16 bit (assuming real) mode.

\begin{verbatim}
bootloader/main.asm
\end{verbatim}
\begin{minted}[linenos,frame=single,breaklines]{nasm}
[org 0x7c00]		; memory load location
[bits 16]		; real mode
\end{minted}

\subsection{Disk read}

Reading from the disk is done with Bios Interrupt 13$_{16}$ ah=02\cite{int 13h}.
\\\\
The interrupt specification is layed out below\cite{int 13h}:
\\

\begin{tabular}{|r|l|}
	\hline
	\textbf{Register} & \textbf{Value} \\
	\hline
	AH & 02 \\
	\hline
	AL & Number of sectors to read \\
	\hline
	CH & Cylinder \\
	\hline
	DH & Head \\
	\hline
	CL & Sector \\
	\hline
	DL & Drive \\
	\hline
	ES:BX & Output offset \\
	\hline
\end{tabular}
\\\\\\
Since the DL register is initialised with the boot drive before control
is handed to our program\cite{boot drive init}, as long as it is not
overwritten before calling int 13$_{16}$, you do not have to alter it.

Since the ES register cannot be written to directly, due to no CPU instruction
being availible to transfer a value to ES\cite{segment cpu write instruction},
which results in an intemediary value needing to be used.

I decided to use BX, due to it being overwritten used in the instruction after,
but any unused register will do. Then, I assigned BX with 7e00$_{16}$, which is
$200_{16}$ bytes more than the start of the program\cite{7c00}, which is the
precise number of bytes loaded by the BIOS\cite{sector size}.

The number of load segments (register AX)\cite{int 13h} have a limit of around 100
on some systems, and around 70 on QEMU. 64 is a safe number of sectors to load,
and allows for 32KB of kernel instructions (which is far more than enough).

Sometimes there will be an error, stored in the carry bit\cite{int 13h}, if this
happens, retry the load from disk. An error may also be indicated by the AL register
having an incorrect number of sectors read.

\begin{verbatim}
bootloader/main.asm
\end{verbatim}
\begin{minted}[linenos,frame=single,breaklines]{nasm}
KERNEL_SEGS equ 64	; KERNEL_SEGS * 512

; read kernel (https://en.wikipedia.org/wiki/INT_13H)
mov bx, 0
mov es, bx
mov bx, 0x7e00		; offset
mov ah, 0x02		; set read mode
mov cl, 2		; start from sec 2
mov al, KERNEL_SEGS	; sectors to read
mov ch, 0		; cylinder
mov dh, 0		; head
int 0x13		; call
jc $$			; carry bit stores error, loop
cmp al, KERNEL_SEGS	; al is sectors read
jne $$			; if all sectors arent read, loop
\end{minted}

\subsection{Segment descriptor}

The Global Descriptor Table is necessary for enabling protected mode\cite{gdt},
and is defined below in a basic form in order to switch to protected mode.

For my kernel, none of the features of the GDT, like paging\cite{gdt page},
are not needed, so the GDT is very basic.

\begin{verbatim}
bootloader/main.asm
\end{verbatim}
\begin{minted}[linenos,frame=single,breaklines]{nasm}
jmp gdt_after

; segment descriptor (reverse order)
gdt_start:
	dq 0		; null byte start
gdt_code:
	dw 0xffff	; segment limit
	db 0,0,0	; segment base
	db 0b10011010	; flags (see wiki)
	db 0b11001111	; 4b flags (see wiki) + seg limit
	db 0		; segment base
gdt_data:
	dw 0xffff	; segment limit
	db 0,0,0	; segment base
	db 0b10010010	; flags (see wiki)
	db 0b11001111	; 4b flags (see wiki) + seg limit
	db 0		; segment base
gdt_end:
	dw gdt_end - gdt_start - 1	; limit
	dd gdt_start			; addr 24 bit
gdt_after:
\end{minted}

\subsection{Usable memory}

The amount of usable memory varies between systems,
and some memory is reserved for hardware, VGA and VBE,
console video memory, etc.

Detecting availible memory blocks is done with interrupt
15$_{16}$\cite{int 15h}. Although you can probably get
away with ignoring this, and just hoping memory above,
lets say 1mb, is completely fine, I went through the extra
effort to correctly get usable memory.

This area repeatedly calls int 15$_{16}$, and saves the result,
if it is larger than the currently tested memory, in a memory location
ironically not tested to see if it is reserved.

The copying and checking is done in two parts due to the fact
that the numbers are larger than the 16 bit memory availible in real mode.

\begin{verbatim}
bootloader/main.asm
\end{verbatim}
\begin{minted}[linenos,frame=single,breaklines]{nasm}
; get largest availible memory block
pusha			; push all
mov cx, 0x0		; clear cx for addition later
xor eax, eax
mov es, eax
mov ebx, 0x0		; clear
mov edx, 0x534d4150	; magic value
memreadloop:
	mov eax, 0xe820	    ; magic value
	mov ecx, 0x18	    ; magic value
	mov di, 0x7bd0	    ; memory location for buffer
	int 0x15	    ; call function
	add di, cx    ; increment di by entry size
	              ; (cx is 16 bit cl)
memreadloopvalid:
	mov eax, [0x7be0]    ; load type
	cmp eax, 1	    ; check if 1 (availible memory)
	jne memreadloopend    ; go to next otherwise
memreadloopcheck:
	mov eax, [0x7bda]	; load size of current
	mov ecx, [0x7bfa]	; load size of biggest
	cmp eax, ecx		; check if bigger
	jle memreadloopend	; go to next otherwise
memreadlooprecord:
	mov eax, [0x7bd0]	; load address of current
	mov [0x7bf0], eax	; record biggest address
	mov eax, [0x7bd4]	; load address of current
	mov [0x7bf4], eax	; record biggest address
	mov eax, [0x7bd8]	; load size of current
	mov [0x7bf8], eax	; record biggest size
	mov eax, [0x7bdc]	; load size of current
	mov [0x7bfc], eax	; record biggest size
memreadloopend:
	cmp ebx, 0		; check if next
	jnz memreadloop		; repeat
\end{minted}

\newpage

\begin{thebibliography}{99}
	\bibitem{7c00}
		Compaq Computer Corporation, Phoenix Technologies Ltd, Intel Corporation (1996)
		\emph{BIOS Boot Specification}
		pg 29 ch 6.5.1
	\bibitem{int 13h}
		Ralf Brown (2000)
		\emph{Ralf Browns Interrupt List}
		interrup b int 13
	\bibitem{sector size}
		IDEMA (2013)
		\emph{The Advent of Advanced Format}
		pg 1
	\bibitem{memory segments}
		Intel Corporation (2016)
		\emph{Intel 64 and IA-32 Architectures Software Developer’s Manual Volume 1: Basic Architecture}
		pg 1.6 ch 1.3.4
	\bibitem{55aa}
		Compaq Computer Corporation, Phoenix Technologies Ltd, Intel Corporation (1996)
		\emph{BIOS Boot Specification}
		pg 12 ch 3.3
	\bibitem{16bitstart}
		Intel Corporation (2016)
		\emph{Intel 64 and IA-32 Architectures Software Developer’s Manual Volume 3A: System Programming Guide, Part 1}
		pg 11.13 ch 1.9.1
	\bibitem{boot drive init}
		Compaq Computer Corporation, Phoenix Technologies Ltd, Intel Corporation (1996)
		\emph{BIOS Boot Specification}
		pg 43 ch D.1
	\bibitem{segment cpu write instruction}
		Intel Corporation (2022)
		\emph{Intel 64 and IA-32 Architectures Software Developer’s Manual Volume 2 (2A, 2B, 2C, 2D): Instruction Set Reference, A-Z}
		pg 4.35 ch 3.3
	\bibitem{gdt}
		Wikipedia (2024)
		\emph{Global Descriptor Table}
		ch Description
	\bibitem{gdt page}
		Wikipedia (2024)
		\emph{Global Descriptor Table}
		ch Modern Usage
	\bibitem{int 15h}
		OsDev (2024)
		\emph{Detecting Memory (x86)}
		ch 2.1
\end{thebibliography}

\end{document}
